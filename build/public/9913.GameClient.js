"use strict";(self.webpackChunkGameClient=self.webpackChunkGameClient||[]).push([[9913],{415:(e,t,n)=>{n(4796).l.IncludesShadersStore.logDepthFragment="#ifdef LOGARITHMICDEPTH\ngl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;\n#endif\n"},540:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.logDepthDeclaration="#ifdef LOGARITHMICDEPTH\nuniform logarithmicDepthConstant: f32;varying vFragmentDepth: f32;\n#endif\n"},944:(e,t,n)=>{n(4796).l.IncludesShadersStore.fogVertex="#ifdef FOG\nvFogDistance=(view*worldPos).xyz;\n#endif\n"},953:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingPixelShader:()=>i});var s=n(4796);n(1407),n(9523),n(4684),n(415),n(4522);s.l.IncludesShadersStore.gaussianSplattingFragmentDeclaration="vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n",n(2250);const r="gaussianSplattingPixelShader",o="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () { \n#include<clipPlaneFragment>\ngl_FragColor=gaussianColor(vColor);}\n";s.l.ShadersStore[r]=o;const i={name:r,shader:o}},1118:(e,t,n)=>{n(4796).l.IncludesShadersStore.sceneUboDeclaration="layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;\n#ifdef MULTIVIEW\nmat4 viewProjectionR;\n#endif \nmat4 view;mat4 projection;vec4 vEyePosition;};\n"},1129:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.fogFragment="#ifdef FOG\nvar fog: f32=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor= vec4f(mix(uniforms.vFogColor,color.rgb,fog),color.a);\n#endif\n"},1277:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.clipPlaneFragment="#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)\nif (false) {}\n#endif\n#ifdef CLIPPLANE\nelse if (fragmentInputs.fClipDistance>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE2\nelse if (fragmentInputs.fClipDistance2>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE3\nelse if (fragmentInputs.fClipDistance3>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE4\nelse if (fragmentInputs.fClipDistance4>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE5\nelse if (fragmentInputs.fClipDistance5>0.0)\n{discard;}\n#endif\n#ifdef CLIPPLANE6\nelse if (fragmentInputs.fClipDistance6>0.0)\n{discard;}\n#endif\n"},1451:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.clipPlaneVertexDeclaration="#ifdef CLIPPLANE\nuniform vClipPlane: vec4<f32>;varying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nuniform vClipPlane2: vec4<f32>;varying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nuniform vClipPlane3: vec4<f32>;varying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nuniform vClipPlane4: vec4<f32>;varying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nuniform vClipPlane5: vec4<f32>;varying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nuniform vClipPlane6: vec4<f32>;varying fClipDistance6: f32;\n#endif\n"},1645:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.sceneUboDeclaration="struct Scene {viewProjection : mat4x4<f32>,\n#ifdef MULTIVIEW\nviewProjectionR : mat4x4<f32>,\n#endif \nview : mat4x4<f32>,\nprojection : mat4x4<f32>,\nvEyePosition : vec4<f32>,};\n#define SCENE_UBO\nvar<uniform> scene : Scene;\n"},1945:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.fogFragmentDeclaration="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\nconst E=2.71828;uniform vFogInfos: vec4f;uniform vFogColor: vec3f;varying vFogDistance: vec3f;fn CalcFogFactor()->f32\n{var fogCoeff: f32=1.0;var fogStart: f32=uniforms.vFogInfos.y;var fogEnd: f32=uniforms.vFogInfos.z;var fogDensity: f32=uniforms.vFogInfos.w;var fogDistance: f32=length(fragmentInputs.vFogDistance);if (FOGMODE_LINEAR==uniforms.vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==uniforms.vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n"},2255:(e,t,n)=>{n(4796).l.IncludesShadersStore.helperFunctions="const float PI=3.1415926535897932384626433832795;const float TWO_PI=6.283185307179586;const float HALF_PI=1.5707963267948966;const float RECIPROCAL_PI=0.3183098861837907;const float RECIPROCAL_PI2=0.15915494309189535;const float RECIPROCAL_PI4=0.07957747154594767;const float HALF_MIN=5.96046448e-08; \nconst float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;\n#define saturate(x) clamp(x,0.0,1.0)\n#define absEps(x) abs(x)+Epsilon\n#define maxEps(x) max(x,Epsilon)\n#define saturateEps(x) clamp(x,Epsilon,1.0)\nmat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(\nvec3(i0.x,i1.x,i2.x),\nvec3(i0.y,i1.y,i2.y),\nvec3(i0.z,i1.z,i2.z)\n);return outMatrix;}\nmat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),\nb11,(a22*a00-a02*a20),(-a12*a00+a02*a10),\nb21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}\n#if USE_EXACT_SRGB_CONVERSIONS\nvec3 toLinearSpaceExact(vec3 color)\n{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));\n#else\nreturn\nvec3(\ncolor.r<=0.04045 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.04045 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.04045 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\nvec3 toGammaSpaceExact(vec3 color)\n{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nreturn mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));\n#else\nreturn\nvec3(\ncolor.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,\ncolor.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,\ncolor.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);\n#endif\n}\n#endif\nfloat toLinearSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,LinearEncodePowerApprox);\n#endif\n}\nvec3 toLinearSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toLinearSpaceExact(color);\n#else\nreturn pow(color,vec3(LinearEncodePowerApprox));\n#endif\n}\nvec4 toLinearSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toLinearSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);\n#endif\n}\nfloat toGammaSpace(float color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nfloat nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;\n#else\nreturn pow(color,GammaEncodePowerApprox);\n#endif\n}\nvec3 toGammaSpace(vec3 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn toGammaSpaceExact(color);\n#else\nreturn pow(color,vec3(GammaEncodePowerApprox));\n#endif\n}\nvec4 toGammaSpace(vec4 color)\n{\n#if USE_EXACT_SRGB_CONVERSIONS\nreturn vec4(toGammaSpaceExact(color.rgb),color.a);\n#else\nreturn vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);\n#endif\n}\nfloat square(float value)\n{return value*value;}\nvec3 square(vec3 value)\n{return value*value;}\nfloat pow5(float value) {float sq=value*value;return sq*sq*value;}\nfloat getLuminance(vec3 color)\n{return saturate(dot(color,LuminanceEncodeApprox));}\nfloat getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}\nfloat dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}\nconst float rgbdMaxRange=255.;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =saturate(floor(D)/255.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(saturate(rgb),D);}\nvec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}\nvec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}\nvec3 equirectangularToCubemapDirection(vec2 uv) {float longitude=uv.x*TWO_PI-PI;float latitude=HALF_PI-uv.y*PI;vec3 direction;direction.x=cos(latitude)*sin(longitude);direction.y=sin(latitude);direction.z=cos(latitude)*cos(longitude);return direction;}\nfloat sqrtClamped(float value) {return sqrt(max(value,0.));}\nfloat avg(vec3 value) {return dot(value,vec3(0.333333333));}"},2274:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingVertexShader:()=>i});var s=n(4796);s.l.IncludesShadersStore.gaussianSplattingVertexDeclaration="attribute vec2 position;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;",n(1118),n(5769);s.l.IncludesShadersStore.gaussianSplattingUboDeclaration="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec2 position;",n(5990),n(6726),n(9523),n(2255);s.l.IncludesShadersStore.gaussianSplatting="#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n};Splat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);splat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 color,vec3 dir)\n{vec3 sh[16];sh[0]=color;\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 color,vec3 dir)\n{return color;}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);mat3 J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);mat3 invy=mat3(1,0,0,0,-1,0,0,0,1);mat3 T=invy*transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;float mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,pos2d.zw);}",n(1328),n(944),n(4217);const r="gaussianSplattingVertexShader",o="#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nattribute float splatIndex;uniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#include<gaussianSplatting>\nvoid main () {Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);vec4 worldPos=world*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(world);mat3 normWorldRot=inverseMat3(worldRot);vec3 dir=normalize(normWorldRot*(worldPos.xyz-vEyePosition.xyz));dir.y*=-1.; \nvColor.xyz=computeSH(splat,splat.color.xyz,dir);\n#endif\ngl_Position=gaussianSplatting(position,worldPos.xyz,vec2(1.,1.),covA,covB,world,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n";s.l.ShadersStore[r]=o;const i={name:r,shader:o}},4217:(e,t,n)=>{n(4796).l.IncludesShadersStore.logDepthVertex="#ifdef LOGARITHMICDEPTH\nvFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;\n#endif\n"},4404:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.meshUboDeclaration="struct Mesh {world : mat4x4<f32>,\nvisibility : f32,};var<uniform> mesh : Mesh;\n#define WORLD_UBO\n"},4522:(e,t,n)=>{n(4796).l.IncludesShadersStore.fogFragment="#ifdef FOG\nfloat fog=CalcFogFactor();\n#ifdef PBR\nfog=toLinearSpace(fog);\n#endif\ncolor.rgb=mix(vFogColor,color.rgb,fog);\n#endif\n"},4684:(e,t,n)=>{n(4796).l.IncludesShadersStore.fogFragmentDeclaration="#ifdef FOG\n#define FOGMODE_NONE 0.\n#define FOGMODE_EXP 1.\n#define FOGMODE_EXP2 2.\n#define FOGMODE_LINEAR 3.\n#define E 2.71828\nuniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()\n{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)\n{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}\nelse if (FOGMODE_EXP==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}\nelse if (FOGMODE_EXP2==vFogInfos.x)\n{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}\nreturn clamp(fogCoeff,0.0,1.0);}\n#endif\n"},4847:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingVertexShaderWGSL:()=>i});var s=n(4796);n(1645),n(4404),n(1451),n(6191),n(540);s.l.IncludesShadersStoreWGSL.gaussianSplatting="fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n};fn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,color: vec3f,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=color;\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);let invy=mat3x3<f32>(\n1.0,0.0,0.0,\n0.0,-1.0,0.0,\n0.0,0.0,1.0\n);let T=invy*transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;let cov2d=transpose(T)*Vrk*T;let mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*pos2d.w)*scale,\npos2d.z,\npos2d.w\n);}\n",n(8679),n(8483),n(9720);const r="gaussianSplattingVertexShader",o="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex: f32;attribute position: vec2f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {var splat: Splat=readSplat(input.splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);let worldPos: vec4f=mesh.world*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position;\n#if SH_DEGREE>0\nlet dir: vec3f=normalize(worldPos.xyz-scene.vEyePosition.xyz);vertexOutputs.vColor=vec4f(computeSH(splat,splat.color.xyz,dir),1.0);\n#else\nvertexOutputs.vColor=splat.color;\n#endif\nvertexOutputs.position=gaussianSplatting(input.position,worldPos.xyz,vec2f(1.0,1.0),covA,covB,mesh.world,scene.view,scene.projection,uniforms.focal,uniforms.invViewport);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n}\n";s.l.ShadersStoreWGSL[r]=o;const i={name:r,shader:o}},5769:(e,t,n)=>{n(4796).l.IncludesShadersStore.meshUboDeclaration="#ifdef WEBGL2\nuniform mat4 world;uniform float visibility;\n#else\nlayout(std140,column_major) uniform;uniform Mesh\n{mat4 world;float visibility;};\n#endif\n#define WORLD_UBO\n"},6191:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.fogVertexDeclaration="#ifdef FOG\nvarying vFogDistance: vec3f;\n#endif\n"},6412:(e,t,n)=>{n.r(t),n.d(t,{gaussianSplattingPixelShaderWGSL:()=>i});var s=n(4796);n(8469),n(540),n(1945),n(9602),n(1129);s.l.IncludesShadersStoreWGSL.gaussianSplattingFragmentDeclaration="fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n",n(1277);const r="gaussianSplattingPixelShader",o="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#include<clipPlaneFragment>\nfragmentOutputs.color=gaussianColor(input.vColor,input.vPosition);}\n";s.l.ShadersStoreWGSL[r]=o;const i={name:r,shader:o}},6726:(e,t,n)=>{n(4796).l.IncludesShadersStore.fogVertexDeclaration="#ifdef FOG\nvarying vec3 vFogDistance;\n#endif\n"},8469:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.clipPlaneFragmentDeclaration="#ifdef CLIPPLANE\nvarying fClipDistance: f32;\n#endif\n#ifdef CLIPPLANE2\nvarying fClipDistance2: f32;\n#endif\n#ifdef CLIPPLANE3\nvarying fClipDistance3: f32;\n#endif\n#ifdef CLIPPLANE4\nvarying fClipDistance4: f32;\n#endif\n#ifdef CLIPPLANE5\nvarying fClipDistance5: f32;\n#endif\n#ifdef CLIPPLANE6\nvarying fClipDistance6: f32;\n#endif\n"},8483:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.fogVertex="#ifdef FOG\n#ifdef SCENE_UBO\nvertexOutputs.vFogDistance=(scene.view*worldPos).xyz;\n#else\nvertexOutputs.vFogDistance=(uniforms.view*worldPos).xyz;\n#endif\n#endif\n"},8679:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.clipPlaneVertex="#ifdef CLIPPLANE\nvertexOutputs.fClipDistance=dot(worldPos,uniforms.vClipPlane);\n#endif\n#ifdef CLIPPLANE2\nvertexOutputs.fClipDistance2=dot(worldPos,uniforms.vClipPlane2);\n#endif\n#ifdef CLIPPLANE3\nvertexOutputs.fClipDistance3=dot(worldPos,uniforms.vClipPlane3);\n#endif\n#ifdef CLIPPLANE4\nvertexOutputs.fClipDistance4=dot(worldPos,uniforms.vClipPlane4);\n#endif\n#ifdef CLIPPLANE5\nvertexOutputs.fClipDistance5=dot(worldPos,uniforms.vClipPlane5);\n#endif\n#ifdef CLIPPLANE6\nvertexOutputs.fClipDistance6=dot(worldPos,uniforms.vClipPlane6);\n#endif\n"},9523:(e,t,n)=>{n(4796).l.IncludesShadersStore.logDepthDeclaration="#ifdef LOGARITHMICDEPTH\nuniform float logarithmicDepthConstant;varying float vFragmentDepth;\n#endif\n"},9602:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.logDepthFragment="#ifdef LOGARITHMICDEPTH\nfragmentOutputs.fragDepth=log2(fragmentInputs.vFragmentDepth)*uniforms.logarithmicDepthConstant*0.5;\n#endif\n"},9720:(e,t,n)=>{n(4796).l.IncludesShadersStoreWGSL.logDepthVertex="#ifdef LOGARITHMICDEPTH\nvertexOutputs.vFragmentDepth=1.0+vertexOutputs.position.w;vertexOutputs.position.z=log2(max(0.000001,vertexOutputs.vFragmentDepth))*uniforms.logarithmicDepthConstant;\n#endif\n"},9913:(e,t,n)=>{n.d(t,{SPLATFileLoader:()=>q});var s=n(1427),r=n(3218),o=n(9593),i=n(9176),a=n(2605),c=n(4049),l=n(3039),u=n(979),f=n(766),h=n(2596),d=n(7638),_=n(5686),p=n(8042),x=n(9642),v=(n(953),n(2274),n(6412),n(4847),n(5241));class m extends h.M{constructor(){super(),this.FOG=!1,this.THIN_INSTANCES=!0,this.LOGARITHMICDEPTH=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.SH_DEGREE=0,this.rebuild()}}class g extends d.E{constructor(e,t){super(e,t),this.backFaceCulling=!1}get hasRenderTargetTextures(){return!1}needAlphaTesting(){return!1}needAlphaBlending(){return!0}isReadyForSubMesh(e,t){const s=!0,r=t._drawWrapper;if(r.effect&&this.isFrozen&&r._wasPreviouslyReady&&r._wasPreviouslyUsingInstances===s)return!0;t.materialDefines||(t.materialDefines=new m);const o=this.getScene(),i=t.materialDefines;if(this._isReadyForSubMesh(t))return!0;const a=o.getEngine();if((0,v.fm)(e,o,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,!1,i),(0,v.OR)(o,a,this,i,s,null,!0),(0,v.qB)(e,i,!1,!1),(a.version>1||a.isWebGPU)&&(i.SH_DEGREE=e.shDegree),i.isDirty){i.markAsProcessed(),o.resetCachedMaterial();const e=[f.R.PositionKind,"splatIndex"];(0,v.ER)(e,i);const s=["world","view","projection","vFogInfos","vFogColor","logarithmicDepthConstant","invViewport","dataTextureSize","focal","vEyePosition"],r=["covariancesATexture","covariancesBTexture","centersTexture","colorsTexture","shTexture0","shTexture1","shTexture2"],c=["Scene","Mesh"];(0,v.Bb)({uniformsNames:s,uniformBuffersNames:c,samplers:r,defines:i}),(0,p.TV)(s);const l=i.toString(),u=o.getEngine().createEffect("gaussianSplatting",{attributes:e,uniformsNames:s,uniformBuffersNames:c,samplers:r,defines:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{},shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{1===this._shaderLanguage?await Promise.all([Promise.resolve().then(n.bind(n,6412)),Promise.resolve().then(n.bind(n,4847))]):await Promise.all([Promise.resolve().then(n.bind(n,953)),Promise.resolve().then(n.bind(n,2274))])}},a);t.setEffect(u,i,this._materialContext)}return!(!t.effect||!t.effect.isReady()||(i._renderId=o.getRenderId(),r._wasPreviouslyReady=!0,r._wasPreviouslyUsingInstances=s,0))}static BindEffect(e,t,n){const s=n.getEngine(),r=n.activeCamera,o=s.getRenderWidth(),i=s.getRenderHeight(),a=r?.rigParent?.rigCameras.length||1;t.setFloat2("invViewport",1/(o/a),1/i);let c=1e3;if(r){const e=r.getProjectionMatrix().m[5];c=r.fovMode==x.i.FOVMODE_VERTICAL_FIXED?i*e/2:o*e/2}t.setFloat2("focal",c,c);const l=e;if(l.covariancesATexture){const e=l.covariancesATexture.getSize();if(t.setFloat2("dataTextureSize",e.width,e.height),t.setTexture("covariancesATexture",l.covariancesATexture),t.setTexture("covariancesBTexture",l.covariancesBTexture),t.setTexture("centersTexture",l.centersTexture),t.setTexture("colorsTexture",l.colorsTexture),l.shTextures)for(let e=0;e<l.shTextures?.length;e++)t.setTexture(`shTexture${e}`,l.shTextures[e])}}bindForSubMesh(e,t,n){const s=this.getScene(),r=n.materialDefines;if(!r)return;const o=n.effect;o&&(this._activeEffect=o,t.getMeshUniformBuffer().bindToEffect(o,"Mesh"),t.transferToEffect(e),this._mustRebind(s,o,n,t.visibility)?(this.bindView(o),this.bindViewProjection(o),g.BindEffect(t,this._activeEffect,s),(0,p.gS)(o,this,s)):s.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0),(0,v.Yy)(s,t,o),this.useLogarithmicDepth&&(0,v.DL)(r,o,s),this._afterBind(t,this._activeEffect,n))}clone(e){return u.p.Clone((()=>new g(e,this.getScene())),this)}serialize(){const e=super.serialize();return e.customType="BABYLON.GaussianSplattingMaterial",e}getClassName(){return"GaussianSplattingMaterial"}static Parse(e,t,n){return u.p.Parse((()=>new g(e.name,t)),e,t,n)}}(0,_.Y5)("BABYLON.GaussianSplattingMaterial",g);var S=n(8551),y=n(9732),C=(n(3785),n(1498)),P=n(2746),E=n(1345),A=n(1497);const w=(e,t)=>{const n=(1<<t)-1;return(e&n)/n},I=(e,t)=>{t.x=w(e>>>21,11),t.y=w(e>>>11,10),t.z=w(e,11)},D=(e,t)=>{t[0]=255*w(e>>>24,8),t[1]=255*w(e>>>16,8),t[2]=255*w(e>>>8,8),t[3]=255*w(e,8)},T=(e,t)=>{const n=1/(.5*Math.sqrt(2)),s=(w(e>>>20,10)-.5)*n,r=(w(e>>>10,10)-.5)*n,o=(w(e,10)-.5)*n,i=Math.sqrt(1-(s*s+r*r+o*o));switch(e>>>30){case 0:t.set(i,s,r,o);break;case 1:t.set(s,i,r,o);break;case 2:t.set(s,r,i,o);break;case 3:t.set(s,r,o,i)}};var b,L;!function(e){e[e.FLOAT=0]="FLOAT",e[e.INT=1]="INT",e[e.UINT=2]="UINT",e[e.DOUBLE=3]="DOUBLE",e[e.UCHAR=4]="UCHAR",e[e.UNDEFINED=5]="UNDEFINED"}(b||(b={})),function(e){e[e.MIN_X=0]="MIN_X",e[e.MIN_Y=1]="MIN_Y",e[e.MIN_Z=2]="MIN_Z",e[e.MAX_X=3]="MAX_X",e[e.MAX_Y=4]="MAX_Y",e[e.MAX_Z=5]="MAX_Z",e[e.MIN_SCALE_X=6]="MIN_SCALE_X",e[e.MIN_SCALE_Y=7]="MIN_SCALE_Y",e[e.MIN_SCALE_Z=8]="MIN_SCALE_Z",e[e.MAX_SCALE_X=9]="MAX_SCALE_X",e[e.MAX_SCALE_Y=10]="MAX_SCALE_Y",e[e.MAX_SCALE_Z=11]="MAX_SCALE_Z",e[e.PACKED_POSITION=12]="PACKED_POSITION",e[e.PACKED_ROTATION=13]="PACKED_ROTATION",e[e.PACKED_SCALE=14]="PACKED_SCALE",e[e.PACKED_COLOR=15]="PACKED_COLOR",e[e.X=16]="X",e[e.Y=17]="Y",e[e.Z=18]="Z",e[e.SCALE_0=19]="SCALE_0",e[e.SCALE_1=20]="SCALE_1",e[e.SCALE_2=21]="SCALE_2",e[e.DIFFUSE_RED=22]="DIFFUSE_RED",e[e.DIFFUSE_GREEN=23]="DIFFUSE_GREEN",e[e.DIFFUSE_BLUE=24]="DIFFUSE_BLUE",e[e.OPACITY=25]="OPACITY",e[e.F_DC_0=26]="F_DC_0",e[e.F_DC_1=27]="F_DC_1",e[e.F_DC_2=28]="F_DC_2",e[e.F_DC_3=29]="F_DC_3",e[e.ROT_0=30]="ROT_0",e[e.ROT_1=31]="ROT_1",e[e.ROT_2=32]="ROT_2",e[e.ROT_3=33]="ROT_3",e[e.MIN_COLOR_R=34]="MIN_COLOR_R",e[e.MIN_COLOR_G=35]="MIN_COLOR_G",e[e.MIN_COLOR_B=36]="MIN_COLOR_B",e[e.MAX_COLOR_R=37]="MAX_COLOR_R",e[e.MAX_COLOR_G=38]="MAX_COLOR_G",e[e.MAX_COLOR_B=39]="MAX_COLOR_B",e[e.SH_0=40]="SH_0",e[e.SH_1=41]="SH_1",e[e.SH_2=42]="SH_2",e[e.SH_3=43]="SH_3",e[e.SH_4=44]="SH_4",e[e.SH_5=45]="SH_5",e[e.SH_6=46]="SH_6",e[e.SH_7=47]="SH_7",e[e.SH_8=48]="SH_8",e[e.SH_9=49]="SH_9",e[e.SH_10=50]="SH_10",e[e.SH_11=51]="SH_11",e[e.SH_12=52]="SH_12",e[e.SH_13=53]="SH_13",e[e.SH_14=54]="SH_14",e[e.SH_15=55]="SH_15",e[e.SH_16=56]="SH_16",e[e.SH_17=57]="SH_17",e[e.SH_18=58]="SH_18",e[e.SH_19=59]="SH_19",e[e.SH_20=60]="SH_20",e[e.SH_21=61]="SH_21",e[e.SH_22=62]="SH_22",e[e.SH_23=63]="SH_23",e[e.SH_24=64]="SH_24",e[e.SH_25=65]="SH_25",e[e.SH_26=66]="SH_26",e[e.SH_27=67]="SH_27",e[e.SH_28=68]="SH_28",e[e.SH_29=69]="SH_29",e[e.SH_30=70]="SH_30",e[e.SH_31=71]="SH_31",e[e.SH_32=72]="SH_32",e[e.SH_33=73]="SH_33",e[e.SH_34=74]="SH_34",e[e.SH_35=75]="SH_35",e[e.SH_36=76]="SH_36",e[e.SH_37=77]="SH_37",e[e.SH_38=78]="SH_38",e[e.SH_39=79]="SH_39",e[e.SH_40=80]="SH_40",e[e.SH_41=81]="SH_41",e[e.SH_42=82]="SH_42",e[e.SH_43=83]="SH_43",e[e.SH_44=84]="SH_44",e[e.UNDEFINED=85]="UNDEFINED"}(L||(L={}));class z extends i.e{get shDegree(){return this._shDegree}get splatsData(){return this._splatsData}get covariancesATexture(){return this._covariancesATexture}get covariancesBTexture(){return this._covariancesBTexture}get centersTexture(){return this._centersTexture}get colorsTexture(){return this._colorsTexture}get shTextures(){return this._shTextures}set material(e){this._material=e,this._material.backFaceCulling=!0,this._material.cullBackFaces=!1,e.resetDrawCache()}get material(){return this._material}constructor(e,t=null,n=null,s=!1){super(e,n),this._vertexCount=0,this._worker=null,this._frameIdLastUpdate=-1,this._modelViewMatrix=c.uq.Identity(),this._canPostToWorker=!0,this._readyToDisplay=!1,this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._splatPositions=null,this._splatIndex=null,this._shTextures=null,this._splatsData=null,this._sh=null,this._keepInRam=!1,this._delayedTextureUpdate=null,this._oldDirection=new c.Pq,this._useRGBACovariants=!1,this._material=null,this._tmpCovariances=[0,0,0,0,0,0],this._sortIsDirty=!1,this._shDegree=0;const r=new a.P;r.positions=[-3,-2,0,3,-2,0,0,4,0],r.indices=[0,1,2],r.applyToMesh(this),this.subMeshes=[],new o.K(0,0,3,0,3,this),this.setEnabled(!1),this._useRGBACovariants=!this.getEngine().isWebGPU&&1===this.getEngine().version,this._keepInRam=s,t&&this.loadFileAsync(t),this._material=new g(this.name+"_material",this._scene)}getClassName(){return"GaussianSplattingMesh"}getTotalVertices(){return this._vertexCount}isReady(e=!1){return!(!super.isReady(e,!0)||!this._readyToDisplay&&(this._postToWorker(!0),1))}_postToWorker(e=!1){const t=this.getScene().getFrameId();if((e||t!==this._frameIdLastUpdate)&&this._worker&&this._scene.activeCamera&&this._canPostToWorker){const n=this._scene.activeCamera.getViewMatrix();this.getWorldMatrix().multiplyToRef(n,this._modelViewMatrix),n.invertToRef(c.AA.Matrix[0]),this.getWorldMatrix().multiplyToRef(c.AA.Matrix[0],c.AA.Matrix[1]),c.Pq.TransformNormalToRef(c.Pq.Forward(this._scene.useRightHandedSystem),c.AA.Matrix[1],c.AA.Vector3[2]),c.AA.Vector3[2].normalize();const s=c.Pq.Dot(c.AA.Vector3[2],this._oldDirection);(e||Math.abs(s-1)>=.01)&&(this._oldDirection.copyFrom(c.AA.Vector3[2]),this._frameIdLastUpdate=t,this._canPostToWorker=!1,this._worker.postMessage({view:this._modelViewMatrix.m,depthMix:this._depthMix,useRightHandedSystem:this._scene.useRightHandedSystem},[this._depthMix.buffer]))}}render(e,t,n){return this._postToWorker(),super.render(e,t,n)}static _TypeNameToEnum(e){switch(e){case"float":return 0;case"int":return 1;case"uint":return 2;case"double":return 3;case"uchar":return 4}return 5}static _ValueNameToEnum(e){switch(e){case"min_x":return 0;case"min_y":return 1;case"min_z":return 2;case"max_x":return 3;case"max_y":return 4;case"max_z":return 5;case"min_scale_x":return 6;case"min_scale_y":return 7;case"min_scale_z":return 8;case"max_scale_x":return 9;case"max_scale_y":return 10;case"max_scale_z":return 11;case"packed_position":return 12;case"packed_rotation":return 13;case"packed_scale":return 14;case"packed_color":return 15;case"x":return 16;case"y":return 17;case"z":return 18;case"scale_0":return 19;case"scale_1":return 20;case"scale_2":return 21;case"diffuse_red":case"red":return 22;case"diffuse_green":case"green":return 23;case"diffuse_blue":case"blue":return 24;case"f_dc_0":return 26;case"f_dc_1":return 27;case"f_dc_2":return 28;case"f_dc_3":return 29;case"opacity":return 25;case"rot_0":return 30;case"rot_1":return 31;case"rot_2":return 32;case"rot_3":return 33;case"min_r":return 34;case"min_g":return 35;case"min_b":return 36;case"max_r":return 37;case"max_g":return 38;case"max_b":return 39;case"f_rest_0":return 40;case"f_rest_1":return 41;case"f_rest_2":return 42;case"f_rest_3":return 43;case"f_rest_4":return 44;case"f_rest_5":return 45;case"f_rest_6":return 46;case"f_rest_7":return 47;case"f_rest_8":return 48;case"f_rest_9":return 49;case"f_rest_10":return 50;case"f_rest_11":return 51;case"f_rest_12":return 52;case"f_rest_13":return 53;case"f_rest_14":return 54;case"f_rest_15":return 55;case"f_rest_16":return 56;case"f_rest_17":return 57;case"f_rest_18":return 58;case"f_rest_19":return 59;case"f_rest_20":return 60;case"f_rest_21":return 61;case"f_rest_22":return 62;case"f_rest_23":return 63;case"f_rest_24":return 64;case"f_rest_25":return 65;case"f_rest_26":return 66;case"f_rest_27":return 67;case"f_rest_28":return 68;case"f_rest_29":return 69;case"f_rest_30":return 70;case"f_rest_31":return 71;case"f_rest_32":return 72;case"f_rest_33":return 73;case"f_rest_34":return 74;case"f_rest_35":return 75;case"f_rest_36":return 76;case"f_rest_37":return 77;case"f_rest_38":return 78;case"f_rest_39":return 79;case"f_rest_40":return 80;case"f_rest_41":return 81;case"f_rest_42":return 82;case"f_rest_43":return 83;case"f_rest_44":return 84}return 85}static ParseHeader(e){const t=new Uint8Array(e),n=(new TextDecoder).decode(t.slice(0,10240)),s=n.indexOf("end_header\n");if(s<0||!n)return null;const r=parseInt(/element vertex (\d+)\n/.exec(n)[1]),o=/element chunk (\d+)\n/.exec(n);let i=0;o&&(i=parseInt(o[1]));let a=0,c=0;const u={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let f;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk"}(f||(f={}));let h=1;const d=[],_=[],p=n.slice(0,s).split("\n");let x=0;for(const e of p)if(e.startsWith("property ")){const[,t,n]=e.split(" "),s=z._ValueNameToEnum(n);s>=84?x=3:s>=64?x=2:s>=48&&(x=1);const r=z._TypeNameToEnum(t);1==h?(_.push({value:s,type:r,offset:c}),c+=u[t]):0==h&&(d.push({value:s,type:r,offset:a}),a+=u[t]),u[t]||l.V.Warn(`Unsupported property type: ${t}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");"chunk"==t?h=1:"vertex"==t&&(h=0)}const v=new DataView(e,s+11),m=new ArrayBuffer(z._RowOutputLength*r);let g=null,S=0;return x&&(S=3*((x+1)*(x+1)-1),g=new ArrayBuffer(S*r)),{vertexCount:r,chunkCount:i,rowVertexLength:a,rowChunkLength:c,vertexProperties:d,chunkProperties:_,dataView:v,buffer:m,shDegree:x,shCoefficientCount:S,shBuffer:g}}static _GetCompressedChunks(e,t){if(!e.chunkCount)return null;const n=e.dataView,s=new Array(e.chunkCount);for(let r=0;r<e.chunkCount;r++){const o={min:new c.Pq,max:new c.Pq,minScale:new c.Pq,maxScale:new c.Pq,minColor:new c.Pq(0,0,0),maxColor:new c.Pq(1,1,1)};s[r]=o;for(let s=0;s<e.chunkProperties.length;s++){const r=e.chunkProperties[s];let i;if(0===r.type)switch(i=n.getFloat32(r.offset+t.value,!0),r.value){case 0:o.min.x=i;break;case 1:o.min.y=i;break;case 2:o.min.z=i;break;case 3:o.max.x=i;break;case 4:o.max.y=i;break;case 5:o.max.z=i;break;case 6:o.minScale.x=i;break;case 7:o.minScale.y=i;break;case 8:o.minScale.z=i;break;case 9:o.maxScale.x=i;break;case 10:o.maxScale.y=i;break;case 11:o.maxScale.z=i;break;case 34:o.minColor.x=i;break;case 35:o.minColor.y=i;break;case 36:o.minColor.z=i;break;case 37:o.maxColor.x=i;break;case 38:o.maxColor.y=i;break;case 39:o.maxColor.z=i}}t.value+=e.rowChunkLength}return s}static _GetSplat(e,t,n,s){const r=c.AA.Quaternion[0],o=c.AA.Vector3[0],i=z._RowOutputLength,a=e.buffer,l=e.dataView,u=new Float32Array(a,t*i,3),f=new Float32Array(a,t*i+12,3),h=new Uint8ClampedArray(a,t*i+24,4),d=new Uint8ClampedArray(a,t*i+28,4);let _=null;e.shBuffer&&(_=new Uint8ClampedArray(e.shBuffer,t*e.shCoefficientCount,e.shCoefficientCount));const p=t>>8;let x=255,v=0,m=0,g=0;for(let t=0;t<e.vertexProperties.length;t++){const i=e.vertexProperties[t];let a;switch(i.type){case 0:a=l.getFloat32(s.value+i.offset,!0);break;case 1:a=l.getInt32(s.value+i.offset,!0);break;case 2:a=l.getUint32(s.value+i.offset,!0);break;case 3:a=l.getFloat64(s.value+i.offset,!0);break;case 4:a=l.getUint8(s.value+i.offset);break;default:continue}switch(i.value){case 12:{const e=n[p];I(a,o),u[0]=P.X.Lerp(e.min.x,e.max.x,o.x),u[1]=P.X.Lerp(e.min.y,e.max.y,o.y),u[2]=P.X.Lerp(e.min.z,e.max.z,o.z)}break;case 13:T(a,r),x=r.w,v=-r.z,m=r.y,g=-r.x;break;case 14:{const e=n[p];I(a,o),f[0]=Math.exp(P.X.Lerp(e.minScale.x,e.maxScale.x,o.x)),f[1]=Math.exp(P.X.Lerp(e.minScale.y,e.maxScale.y,o.y)),f[2]=Math.exp(P.X.Lerp(e.minScale.z,e.maxScale.z,o.z))}break;case 15:{const e=n[p];D(a,h),h[0]=255*P.X.Lerp(e.minColor.x,e.maxColor.x,h[0]/255),h[1]=255*P.X.Lerp(e.minColor.y,e.maxColor.y,h[1]/255),h[2]=255*P.X.Lerp(e.minColor.z,e.maxColor.z,h[2]/255)}break;case 16:u[0]=a;break;case 17:u[1]=a;break;case 18:u[2]=a;break;case 19:f[0]=Math.exp(a);break;case 20:f[1]=Math.exp(a);break;case 21:f[2]=Math.exp(a);break;case 22:h[0]=a;break;case 23:h[1]=a;break;case 24:h[2]=a;break;case 26:h[0]=255*(.5+z._SH_C0*a);break;case 27:h[1]=255*(.5+z._SH_C0*a);break;case 28:h[2]=255*(.5+z._SH_C0*a);break;case 29:h[3]=255*(.5+z._SH_C0*a);break;case 25:h[3]=1/(1+Math.exp(-a))*255;break;case 30:x=a;break;case 31:v=a;break;case 32:m=a;break;case 33:g=a}if(_&&i.value>=40&&i.value<=84){const e=P.X.Clamp(127.5*a+127.5,0,255);_[i.value-40]=e}}r.set(v,m,g,x),r.normalize(),d[0]=128*r.w+128,d[1]=128*r.x+128,d[2]=128*r.y+128,d[3]=128*r.z+128,s.value+=e.rowVertexLength}static*ConvertPLYWithSHToSplat(e,t=!1){const n=z.ParseHeader(e);if(!n)return{buffer:e};const s={value:0},r=z._GetCompressedChunks(n,s);for(let e=0;e<n.vertexCount;e++)z._GetSplat(n,e,r,s),e%z._PlyConversionBatchSize==0&&t&&(yield);let o=null;if(n.shDegree&&n.shBuffer){const e=Math.ceil(n.shCoefficientCount/16);let t=0;const s=new Uint8Array(n.shBuffer);o=[];const r=n.vertexCount,i=A.q.LastCreatedEngine;if(i){const a=i.getCaps().maxTextureSize,c=Math.ceil(r/a);for(let t=0;t<e;t++){const e=new Uint8Array(c*a*4*4);o.push(e)}for(let e=0;e<r;e++)for(let r=0;r<n.shCoefficientCount;r++){const n=s[t++];o[Math.floor(r/16)][r%16+16*e]=n}}}return{buffer:n.buffer,sh:o}}static*ConvertPLYToSplat(e,t=!1){const n=z.ParseHeader(e);if(!n)return e;const s={value:0},r=z._GetCompressedChunks(n,s);for(let e=0;e<n.vertexCount;e++)z._GetSplat(n,e,r,s),e%z._PlyConversionBatchSize==0&&t&&(yield);return n.buffer}static async ConvertPLYToSplatAsync(e){return(0,E.kj)(z.ConvertPLYToSplat(e,!0),(0,E.VP)())}static async ConvertPLYWithSHToSplatAsync(e){return(0,E.kj)(z.ConvertPLYWithSHToSplat(e,!0),(0,E.VP)())}loadDataAsync(e){return this.updateDataAsync(e)}loadFileAsync(e){return y.S0.LoadFileAsync(e,!0).then((async e=>{z.ConvertPLYWithSHToSplatAsync(e).then((e=>{this.updateDataAsync(e.buffer,e.sh)}))}))}dispose(e){this._covariancesATexture?.dispose(),this._covariancesBTexture?.dispose(),this._centersTexture?.dispose(),this._colorsTexture?.dispose(),this._shTextures&&this._shTextures.forEach((e=>{e.dispose()})),this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._shTextures=null,this._worker?.terminate(),this._worker=null,super.dispose(e,!0)}_copyTextures(e){this._covariancesATexture=e.covariancesATexture?.clone(),this._covariancesBTexture=e.covariancesBTexture?.clone(),this._centersTexture=e.centersTexture?.clone(),this._colorsTexture=e.colorsTexture?.clone(),e._shTextures&&(this._shTextures=[],this._shTextures.forEach((e=>{this._shTextures?.push(e.clone())})))}clone(e=""){const t=new z(e,void 0,this.getScene());t._copySource(this),t.makeGeometryUnique(),t._vertexCount=this._vertexCount,t._copyTextures(this),t._modelViewMatrix=c.uq.Identity(),t._splatPositions=this._splatPositions,t._readyToDisplay=!1,t._instanciateWorker();const n=this.getBoundingInfo();return t.getBoundingInfo().reConstruct(n.minimum,n.maximum,this.getWorldMatrix()),t.forcedInstanceCount=t._vertexCount,t.setEnabled(!0),t}_makeSplat(e,t,n,s,r,o,i,a){const l=c.AA.Matrix[0],u=c.AA.Matrix[1],f=c.AA.Quaternion[0],h=this._useRGBACovariants?4:2,d=t[8*e+0],_=-t[8*e+1],p=t[8*e+2];this._splatPositions[4*e+0]=d,this._splatPositions[4*e+1]=_,this._splatPositions[4*e+2]=p,i.minimizeInPlaceFromFloats(d,_,p),a.maximizeInPlaceFromFloats(d,_,p),f.set((n[32*e+28+1]-127.5)/127.5,(n[32*e+28+2]-127.5)/127.5,(n[32*e+28+3]-127.5)/127.5,-(n[32*e+28+0]-127.5)/127.5),f.toRotationMatrix(l),c.uq.ScalingToRef(2*t[8*e+3+0],2*t[8*e+3+1],2*t[8*e+3+2],u);const x=l.multiplyToRef(u,c.AA.Matrix[0]).m,v=this._tmpCovariances;v[0]=x[0]*x[0]+x[1]*x[1]+x[2]*x[2],v[1]=x[0]*x[4]+x[1]*x[5]+x[2]*x[6],v[2]=x[0]*x[8]+x[1]*x[9]+x[2]*x[10],v[3]=x[4]*x[4]+x[5]*x[5]+x[6]*x[6],v[4]=x[4]*x[8]+x[5]*x[9]+x[6]*x[10],v[5]=x[8]*x[8]+x[9]*x[9]+x[10]*x[10];let m=-1e4;for(let e=0;e<6;e++)m=Math.max(m,Math.abs(v[e]));this._splatPositions[4*e+3]=m;const g=m;s[4*e+0]=(0,C.LZ)(v[0]/g),s[4*e+1]=(0,C.LZ)(v[1]/g),s[4*e+2]=(0,C.LZ)(v[2]/g),s[4*e+3]=(0,C.LZ)(v[3]/g),r[e*h+0]=(0,C.LZ)(v[4]/g),r[e*h+1]=(0,C.LZ)(v[5]/g),o[4*e+0]=n[32*e+24+0],o[4*e+1]=n[32*e+24+1],o[4*e+2]=n[32*e+24+2],o[4*e+3]=n[32*e+24+3]}_updateTextures(e,t,n,s){const r=this._getTextureSize(this._vertexCount),o=(e,t,n,s)=>new S.I(e,t,n,s,this._scene,!1,!1,1,7),i=(e,t,n,s)=>new S.I(e,t,n,s,this._scene,!1,!1,2,2);if(this._covariancesATexture){this._delayedTextureUpdate={covA:e,covB:t,colors:n,centers:this._splatPositions,sh:s};const r=Float32Array.from(this._splatPositions),o=this._vertexCount;this._worker.postMessage({positions:r,vertexCount:o},[r.buffer]),this._postToWorker(!0)}else this._covariancesATexture=i(e,r.x,r.y,5),this._covariancesBTexture=i(t,r.x,r.y,this._useRGBACovariants?5:7),this._centersTexture=((e,t,n,s)=>new S.I(e,t,n,s,this._scene,!1,!1,2,1))(this._splatPositions,r.x,r.y,5),this._colorsTexture=((e,t,n,s)=>new S.I(e,t,n,s,this._scene,!1,!1,2,0))(n,r.x,r.y,5),s&&(this._shTextures=[],s.forEach((e=>{const t=new Uint32Array(e.buffer),n=o(t,r.x,r.y,11);n.wrapU=0,n.wrapV=0,this._shTextures.push(n)}))),this._instanciateWorker()}*_updateData(e,t,n){this._covariancesATexture||(this._readyToDisplay=!1);const s=new Uint8Array(e),r=new Float32Array(s.buffer);this._keepInRam&&(this._splatsData=e,n&&(this._sh=n));const o=s.length/z._RowOutputLength;o!=this._vertexCount&&this._updateSplatIndexBuffer(o),this._vertexCount=o,this._shDegree=n?n.length:0;const i=this._getTextureSize(o),a=i.x*i.y,l=z.ProgressiveUpdateAmount??i.y,u=i.x*l;this._splatPositions=new Float32Array(4*a);const f=new Uint16Array(4*a),h=new Uint16Array((this._useRGBACovariants?4:2)*a),d=new Uint8Array(4*a),_=new c.Pq(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),p=new c.Pq(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(z.ProgressiveUpdateAmount){this._updateTextures(f,h,d,n),this.setEnabled(!0);const e=Math.ceil(i.y/l);for(let n=0;n<e;n++){const e=n*l,o=e*i.x;for(let e=0;e<u;e++)this._makeSplat(o+e,r,s,f,h,d,_,p);this._updateSubTextures(this._splatPositions,f,h,d,e,Math.min(l,i.y-e)),this.getBoundingInfo().reConstruct(_,p,this.getWorldMatrix()),t&&(yield)}const o=Float32Array.from(this._splatPositions),a=this._vertexCount;this._worker.postMessage({positions:o,vertexCount:a},[o.buffer]),this._sortIsDirty=!0}else{for(let e=0;e<o;e++)this._makeSplat(e,r,s,f,h,d,_,p),t&&e%z._SplatBatchSize==0&&(yield);this._updateTextures(f,h,d,n),this.getBoundingInfo().reConstruct(_,p,this.getWorldMatrix()),this.setEnabled(!0)}this._postToWorker(!0)}async updateDataAsync(e,t){return(0,E.kj)(this._updateData(e,!0,t),(0,E.VP)())}updateData(e,t){(0,E.V1)(this._updateData(e,!1,t))}refreshBoundingInfo(){return this.thinInstanceRefreshBoundingInfo(!1),this}_updateSplatIndexBuffer(e){(!this._splatIndex||e>this._splatIndex.length)&&(this._splatIndex=new Float32Array(e),this.thinInstanceSetBuffer("splatIndex",this._splatIndex,1,!1)),this.forcedInstanceCount=e}_updateSubTextures(e,t,n,s,r,o,i){const a=(e,t,n,s,r)=>{this.getEngine().updateTextureData(e.getInternalTexture(),t,0,s,n,r,0,0,!1)},c=this._getTextureSize(this._vertexCount),l=this._useRGBACovariants?4:2,u=r*c.x,f=o*c.x,h=new Uint16Array(t.buffer,4*u*Uint16Array.BYTES_PER_ELEMENT,4*f),d=new Uint16Array(n.buffer,u*l*Uint16Array.BYTES_PER_ELEMENT,f*l),_=new Uint8Array(s.buffer,4*u,4*f),p=new Float32Array(e.buffer,4*u*Float32Array.BYTES_PER_ELEMENT,4*f);if(a(this._covariancesATexture,h,c.x,r,o),a(this._covariancesBTexture,d,c.x,r,o),a(this._centersTexture,p,c.x,r,o),a(this._colorsTexture,_,c.x,r,o),i)for(let e=0;e<i.length;e++){const t=4,n=new Uint8Array(this._sh[e].buffer,u*t,f*t);a(this._shTextures[e],n,c.x,r,o)}}_instanciateWorker(){if(!this._vertexCount)return;this._updateSplatIndexBuffer(this._vertexCount),this._worker?.terminate(),this._worker=new Worker(URL.createObjectURL(new Blob(["(",z._CreateWorker.toString(),")(self)"],{type:"application/javascript"}))),this._depthMix=new BigInt64Array(this._vertexCount);const e=Float32Array.from(this._splatPositions),t=this._vertexCount;this._worker.postMessage({positions:e,vertexCount:t},[e.buffer]),this._worker.onmessage=e=>{this._depthMix=e.data.depthMix;const n=new Uint32Array(e.data.depthMix.buffer);if(this._splatIndex)for(let e=0;e<this._vertexCount;e++)this._splatIndex[e]=n[2*e];if(this._delayedTextureUpdate){const e=this._getTextureSize(t);this._updateSubTextures(this._delayedTextureUpdate.centers,this._delayedTextureUpdate.covA,this._delayedTextureUpdate.covB,this._delayedTextureUpdate.colors,0,e.y,this._delayedTextureUpdate.sh),this._delayedTextureUpdate=null}this.thinInstanceBufferUpdated("splatIndex"),this._canPostToWorker=!0,this._readyToDisplay=!0,this._sortIsDirty&&(this._postToWorker(!0),this._sortIsDirty=!1)}}_getTextureSize(e){const t=this._scene.getEngine(),n=t.getCaps().maxTextureSize;let s=1;if(1!==t.version||t.isWebGPU)s=Math.ceil(e/n);else for(;n*s<e;)s*=2;return s>n&&(l.V.Error("GaussianSplatting texture size: ("+n+", "+s+"), maxTextureSize: "+n),s=n),new c.I9(n,s)}}z._RowOutputLength=32,z._SH_C0=.28209479177387814,z._SplatBatchSize=327680,z._PlyConversionBatchSize=32768,z.ProgressiveUpdateAmount=0,z._CreateWorker=function(e){let t,n,s,r,o=0;e.onmessage=i=>{if(i.data.positions)t=i.data.positions,o=i.data.vertexCount;else{const a=i.data.view;if(!t||!a)throw new Error("positions or view is not defined!");n=i.data.depthMix,s=new Uint32Array(n.buffer),r=new Float32Array(n.buffer);for(let e=0;e<o;e++)s[2*e]=e;let c=-1;i.data.useRightHandedSystem&&(c=1);for(let e=0;e<o;e++)r[2*e+1]=1e4+(a[2]*t[4*e+0]+a[6]*t[4*e+1]+a[10]*t[4*e+2])*c;n.sort(),e.postMessage({depthMix:n},[n.buffer])}}};var M=n(4915),H=n(3086);class R{constructor(e,t,n,s,r){this.idx=0,this.color=new H.ov(1,1,1,1),this.position=H.Pq.Zero(),this.rotation=H.Pq.Zero(),this.uv=new H.I9(0,0),this.velocity=H.Pq.Zero(),this.pivot=H.Pq.Zero(),this.translateFromPivot=!1,this._pos=0,this._ind=0,this.groupId=0,this.idxInGroup=0,this._stillInvisible=!1,this._rotationMatrix=[1,0,0,0,1,0,0,0,1],this.parentId=null,this._globalPosition=H.Pq.Zero(),this.idx=e,this._group=t,this.groupId=n,this.idxInGroup=s,this._pcs=r}get size(){return this.size}set size(e){this.size=e}get quaternion(){return this.rotationQuaternion}set quaternion(e){this.rotationQuaternion=e}intersectsMesh(e,t){if(!e.hasBoundingInfo)return!1;if(!this._pcs.mesh)throw new Error("Point Cloud System doesnt contain the Mesh");if(t)return e.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));const n=e.getBoundingInfo().boundingBox,s=n.maximumWorld.x,r=n.minimumWorld.x,o=n.maximumWorld.y,i=n.minimumWorld.y,a=n.maximumWorld.z,c=n.minimumWorld.z,l=this.position.x+this._pcs.mesh.position.x,u=this.position.y+this._pcs.mesh.position.y,f=this.position.z+this._pcs.mesh.position.z;return r<=l&&l<=s&&i<=u&&u<=o&&c<=f&&f<=a}getRotationMatrix(e){let t;if(this.rotationQuaternion)t=this.rotationQuaternion;else{t=H.AA.Quaternion[0];const e=this.rotation;H.PT.RotationYawPitchRollToRef(e.y,e.x,e.z,t)}t.toRotationMatrix(e)}}class F{get groupID(){return this.groupId}set groupID(e){this.groupId=e}constructor(e,t){this.groupId=e,this._positionFunction=t}}var V,O=n(780),B=n(6863),U=n(3113),G=n(8857);!function(e){e[e.Color=2]="Color",e[e.UV=1]="UV",e[e.Random=0]="Random",e[e.Stated=3]="Stated"}(V||(V={}));class N{get positions(){return this._positions32}get colors(){return this._colors32}get uvs(){return this._uvs32}constructor(e,t,n,s){this.particles=new Array,this.nbParticles=0,this.counter=0,this.vars={},this._promises=[],this._positions=new Array,this._indices=new Array,this._normals=new Array,this._colors=new Array,this._uvs=new Array,this._updatable=!0,this._isVisibilityBoxLocked=!1,this._alwaysVisible=!1,this._groups=new Array,this._groupCounter=0,this._computeParticleColor=!0,this._computeParticleTexture=!0,this._computeParticleRotation=!0,this._computeBoundingBox=!1,this._isReady=!1,this.name=e,this._size=t,this._scene=n||A.q.LastCreatedScene,s&&void 0!==s.updatable?this._updatable=s.updatable:this._updatable=!0}buildMeshAsync(e){return Promise.all(this._promises).then((()=>(this._isReady=!0,this._buildMesh(e))))}_buildMesh(e){0===this.nbParticles&&this.addPoints(1),this._positions32=new Float32Array(this._positions),this._uvs32=new Float32Array(this._uvs),this._colors32=new Float32Array(this._colors);const t=new a.P;t.set(this._positions32,f.R.PositionKind),this._uvs32.length>0&&t.set(this._uvs32,f.R.UVKind);let n=0;this._colors32.length>0&&(n=1,t.set(this._colors32,f.R.ColorKind));const s=new i.e(this.name,this._scene);t.applyToMesh(s,this._updatable),this.mesh=s,this._positions=null,this._uvs=null,this._colors=null,this._updatable||(this.particles.length=0);let r=e;return r||(r=new B.F("point cloud material",this._scene),r.emissiveColor=new H.v9(n,n,n),r.disableLighting=!0,r.pointsCloud=!0,r.pointSize=this._size),s.material=r,new Promise((e=>e(s)))}_addParticle(e,t,n,s){const r=new R(e,t,n,s,this);return this.particles.push(r),r}_randomUnitVector(e){e.position=new c.Pq(Math.random(),Math.random(),Math.random()),e.color=new H.ov(1,1,1,1)}_getColorIndicesForCoord(e,t,n,s){const r=e._groupImageData,o=n*(4*s)+4*t,i=[o,o+1,o+2,o+3],a=i[1],c=i[2],l=i[3],u=r[i[0]],f=r[a],h=r[c],d=r[l];return new H.ov(u/255,f/255,h/255,d)}_setPointsColorOrUV(e,t,n,s,r,o,i,a){a=a??0,n&&e.updateFacetData();const l=2*e.getBoundingInfo().boundingSphere.radius;let u=e.getVerticesData(f.R.PositionKind);const h=e.getIndices(),d=e.getVerticesData(f.R.UVKind+(a?a+1:"")),_=e.getVerticesData(f.R.ColorKind),p=c.Pq.Zero();e.computeWorldMatrix();const x=e.getWorldMatrix();if(!x.isIdentity()){u=u.slice(0);for(let e=0;e<u.length/3;e++)c.Pq.TransformCoordinatesFromFloatsToRef(u[3*e],u[3*e+1],u[3*e+2],x,p),u[3*e]=p.x,u[3*e+1]=p.y,u[3*e+2]=p.z}let v=0,m=0,g=0,S=0,y=0,C=0,P=0,E=0,A=0,w=0,I=0,D=0,T=0;const b=c.Pq.Zero(),L=c.Pq.Zero(),z=c.Pq.Zero(),M=c.Pq.Zero(),R=c.Pq.Zero();let F=0,V=0,B=0,U=0,N=0,k=0;const W=c.I9.Zero(),q=c.I9.Zero(),Z=c.I9.Zero(),X=c.I9.Zero(),Y=c.I9.Zero();let j=0,K=0,Q=0,J=0,$=0,ee=0,te=0,ne=0,se=0,re=0,oe=0,ie=0;const ae=c.IU.Zero(),ce=c.IU.Zero(),le=c.IU.Zero(),ue=c.IU.Zero(),fe=c.IU.Zero();let he,de,_e=0,pe=0;i=i||0;let xe=new c.IU(0,0,0,0),ve=c.Pq.Zero(),me=c.Pq.Zero(),ge=c.Pq.Zero(),Se=0,ye=c.Pq.Zero(),Ce=0,Pe=0;const Ee=new O.Rl(c.Pq.Zero(),new c.Pq(1,0,0));let Ae,we=c.Pq.Zero();for(let a=0;a<h.length/3;a++){let f,p,x,O,Ie,De,Te,be;m=h[3*a],g=h[3*a+1],S=h[3*a+2],y=u[3*m],C=u[3*m+1],P=u[3*m+2],E=u[3*g],A=u[3*g+1],w=u[3*g+2],I=u[3*S],D=u[3*S+1],T=u[3*S+2],b.set(y,C,P),L.set(E,A,w),z.set(I,D,T),L.subtractToRef(b,M),z.subtractToRef(L,R),d&&(F=d[2*m],V=d[2*m+1],B=d[2*g],U=d[2*g+1],N=d[2*S],k=d[2*S+1],W.set(F,V),q.set(B,U),Z.set(N,k),q.subtractToRef(W,X),Z.subtractToRef(q,Y)),_&&s&&(j=_[4*m],K=_[4*m+1],Q=_[4*m+2],J=_[4*m+3],$=_[4*g],ee=_[4*g+1],te=_[4*g+2],ne=_[4*g+3],se=_[4*S],re=_[4*S+1],oe=_[4*S+2],ie=_[4*S+3],ae.set(j,K,Q,J),ce.set($,ee,te,ne),le.set(se,re,oe,ie),ce.subtractToRef(ae,ue),le.subtractToRef(ce,fe));const Le=new H.v9(0,0,0),ze=new H.v9(0,0,0);let Me,He;for(let u=0;u<t._groupDensity[a];u++)v=this.particles.length,this._addParticle(v,t,this._groupCounter,a+u),He=this.particles[v],_e=Math.sqrt((0,G.RandomRange)(0,1)),pe=(0,G.RandomRange)(0,1),he=b.add(M.scale(_e)).add(R.scale(_e*pe)),n&&(ve=e.getFacetNormal(a).normalize().scale(-1),me=M.clone().normalize(),ge=c.Pq.Cross(ve,me),Se=(0,G.RandomRange)(0,2*Math.PI),ye=me.scale(Math.cos(Se)).add(ge.scale(Math.sin(Se))),Se=(0,G.RandomRange)(.1,Math.PI/2),we=ye.scale(Math.cos(Se)).add(ve.scale(Math.sin(Se))),Ee.origin=he.add(we.scale(1e-5)),Ee.direction=we,Ee.length=l,Ae=Ee.intersectsMesh(e),Ae.hit&&(Pe=Ae.pickedPoint.subtract(he).length(),Ce=(0,G.RandomRange)(0,1)*Pe,he.addInPlace(we.scale(Ce)))),He.position=he.clone(),this._positions.push(He.position.x,He.position.y,He.position.z),void 0!==s?d&&(de=W.add(X.scale(_e)).add(Y.scale(_e*pe)),s?r&&null!==t._groupImageData?(f=t._groupImgWidth,p=t._groupImgHeight,Me=this._getColorIndicesForCoord(t,Math.round(de.x*f),Math.round(de.y*p),f),He.color=Me,this._colors.push(Me.r,Me.g,Me.b,Me.a)):_?(xe=ae.add(ue.scale(_e)).add(fe.scale(_e*pe)),He.color=new H.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w)):(xe=ae.set(Math.random(),Math.random(),Math.random(),1),He.color=new H.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w)):(He.uv=de.clone(),this._uvs.push(He.uv.x,He.uv.y))):(o?(Le.set(o.r,o.g,o.b),x=(0,G.RandomRange)(-i,i),O=(0,G.RandomRange)(-i,i),be=Le.toHSV(),Ie=be.r,De=be.g+x,Te=be.b+O,De<0&&(De=0),De>1&&(De=1),Te<0&&(Te=0),Te>1&&(Te=1),H.v9.HSVtoRGBToRef(Ie,De,Te,ze),xe.set(ze.r,ze.g,ze.b,1)):xe=ae.set(Math.random(),Math.random(),Math.random(),1),He.color=new H.ov(xe.x,xe.y,xe.z,xe.w),this._colors.push(xe.x,xe.y,xe.z,xe.w))}}_colorFromTexture(e,t,n){if(null===e.material)return l.V.Warn(e.name+"has no material."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,n,!0,!1);const s=e.material.getActiveTextures();if(0===s.length)return l.V.Warn(e.name+"has no usable texture."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,n,!0,!1);const r=e.clone();r.setEnabled(!1),this._promises.push(new Promise((e=>{U.t.WhenAllReady(s,(()=>{let o=t._textureNb;o<0&&(o=0),o>s.length-1&&(o=s.length-1);const i=()=>{t._groupImgWidth=s[o].getSize().width,t._groupImgHeight=s[o].getSize().height,this._setPointsColorOrUV(r,t,n,!0,!0,void 0,void 0,s[o].coordinatesIndex),r.dispose(),e()};t._groupImageData=null;const a=s[o].readPixels();a?a.then((e=>{t._groupImageData=e,i()})):i()}))})))}_calculateDensity(e,t,n){let s,r,o,i,a,l,u,f,h,d,_,p;const x=c.Pq.Zero(),v=c.Pq.Zero(),m=c.Pq.Zero(),g=c.Pq.Zero(),S=c.Pq.Zero(),y=c.Pq.Zero();let C;const P=[];let E=0;const A=n.length/3;for(let e=0;e<A;e++)s=n[3*e],r=n[3*e+1],o=n[3*e+2],i=t[3*s],a=t[3*s+1],l=t[3*s+2],u=t[3*r],f=t[3*r+1],h=t[3*r+2],d=t[3*o],_=t[3*o+1],p=t[3*o+2],x.set(i,a,l),v.set(u,f,h),m.set(d,_,p),v.subtractToRef(x,g),m.subtractToRef(v,S),c.Pq.CrossToRef(g,S,y),C=.5*y.length(),E+=C,P[e]=E;const w=new Array(A);let I=e;for(let e=A-1;e>0;e--){const t=P[e];if(0===t)w[e]=0;else{const n=(t-P[e-1])/t*I,s=Math.floor(n),r=n-s,o=s+Number(Math.random()<r);w[e]=o,I-=o}}return w[0]=I,w}addPoints(e,t=this._randomUnitVector){const n=new F(this._groupCounter,t);let s,r=this.nbParticles;for(let t=0;t<e;t++)s=this._addParticle(r,n,this._groupCounter,t),n&&n._positionFunction&&n._positionFunction(s,r,t),this._positions.push(s.position.x,s.position.y,s.position.z),s.color&&this._colors.push(s.color.r,s.color.g,s.color.b,s.color.a),s.uv&&this._uvs.push(s.uv.x,s.uv.y),r++;return this.nbParticles+=e,this._groupCounter++,this._groupCounter}addSurfacePoints(e,t,n,s,r){let o=n||0;(isNaN(o)||o<0||o>3)&&(o=0);const i=e.getVerticesData(f.R.PositionKind),a=e.getIndices();this._groups.push(this._groupCounter);const c=new F(this._groupCounter,null);switch(c._groupDensity=this._calculateDensity(t,i,a),2===o?c._textureNb=s||0:s=s||new H.ov(1,1,1,1),o){case 2:this._colorFromTexture(e,c,!1);break;case 1:this._setPointsColorOrUV(e,c,!1,!1,!1);break;case 0:this._setPointsColorOrUV(e,c,!1);break;case 3:this._setPointsColorOrUV(e,c,!1,void 0,void 0,s,r)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}addVolumePoints(e,t,n,s,r){let o=n||0;(isNaN(o)||o<0||o>3)&&(o=0);const i=e.getVerticesData(f.R.PositionKind),a=e.getIndices();this._groups.push(this._groupCounter);const c=new F(this._groupCounter,null);switch(c._groupDensity=this._calculateDensity(t,i,a),2===o?c._textureNb=s||0:s=s||new H.ov(1,1,1,1),o){case 2:this._colorFromTexture(e,c,!0);break;case 1:this._setPointsColorOrUV(e,c,!0,!1,!1);break;case 0:this._setPointsColorOrUV(e,c,!0);break;case 3:this._setPointsColorOrUV(e,c,!0,void 0,void 0,s,r)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}setParticles(e=0,t=this.nbParticles-1,n=!0){if(!this._updatable||!this._isReady)return this;this.beforeUpdateParticles(e,t,n);const s=c.AA.Matrix[0],r=this.mesh,o=this._colors32,i=this._positions32,a=this._uvs32,l=c.AA.Vector3,u=l[5].copyFromFloats(1,0,0),h=l[6].copyFromFloats(0,1,0),d=l[7].copyFromFloats(0,0,1),_=l[8].setAll(Number.MAX_VALUE),p=l[9].setAll(-Number.MAX_VALUE);c.uq.IdentityToRef(s);let x=0;if(this.mesh?.isFacetDataEnabled&&(this._computeBoundingBox=!0),t=t>=this.nbParticles?this.nbParticles-1:t,this._computeBoundingBox&&(0!=e||t!=this.nbParticles-1)){const e=this.mesh?.getBoundingInfo();e&&(_.copyFrom(e.minimum),p.copyFrom(e.maximum))}x=0;let v=0,m=0,g=0;for(let n=e;n<=t;n++){const e=this.particles[n];x=e.idx,v=3*x,m=4*x,g=2*x,this.updateParticle(e);const t=e._rotationMatrix,r=e.position,o=e._globalPosition;if(this._computeParticleRotation&&e.getRotationMatrix(s),null!==e.parentId){const n=this.particles[e.parentId],i=n._rotationMatrix,a=n._globalPosition,c=r.x*i[1]+r.y*i[4]+r.z*i[7],l=r.x*i[0]+r.y*i[3]+r.z*i[6],u=r.x*i[2]+r.y*i[5]+r.z*i[8];if(o.x=a.x+l,o.y=a.y+c,o.z=a.z+u,this._computeParticleRotation){const e=s.m;t[0]=e[0]*i[0]+e[1]*i[3]+e[2]*i[6],t[1]=e[0]*i[1]+e[1]*i[4]+e[2]*i[7],t[2]=e[0]*i[2]+e[1]*i[5]+e[2]*i[8],t[3]=e[4]*i[0]+e[5]*i[3]+e[6]*i[6],t[4]=e[4]*i[1]+e[5]*i[4]+e[6]*i[7],t[5]=e[4]*i[2]+e[5]*i[5]+e[6]*i[8],t[6]=e[8]*i[0]+e[9]*i[3]+e[10]*i[6],t[7]=e[8]*i[1]+e[9]*i[4]+e[10]*i[7],t[8]=e[8]*i[2]+e[9]*i[5]+e[10]*i[8]}}else if(o.x=0,o.y=0,o.z=0,this._computeParticleRotation){const e=s.m;t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10]}const a=l[11];e.translateFromPivot?a.setAll(0):a.copyFrom(e.pivot);const c=l[0];c.copyFrom(e.position);const f=c.x-e.pivot.x,S=c.y-e.pivot.y,y=c.z-e.pivot.z;let C=f*t[0]+S*t[3]+y*t[6],P=f*t[1]+S*t[4]+y*t[7],E=f*t[2]+S*t[5]+y*t[8];C+=a.x,P+=a.y,E+=a.z;const A=i[v]=o.x+u.x*C+h.x*P+d.x*E,w=i[v+1]=o.y+u.y*C+h.y*P+d.y*E,I=i[v+2]=o.z+u.z*C+h.z*P+d.z*E;if(this._computeBoundingBox&&(_.minimizeInPlaceFromFloats(A,w,I),p.maximizeInPlaceFromFloats(A,w,I)),this._computeParticleColor&&e.color){const t=e.color,n=this._colors32;n[m]=t.r,n[m+1]=t.g,n[m+2]=t.b,n[m+3]=t.a}if(this._computeParticleTexture&&e.uv){const t=e.uv,n=this._uvs32;n[g]=t.x,n[g+1]=t.y}}return r&&(n&&(this._computeParticleColor&&r.updateVerticesData(f.R.ColorKind,o,!1,!1),this._computeParticleTexture&&r.updateVerticesData(f.R.UVKind,a,!1,!1),r.updateVerticesData(f.R.PositionKind,i,!1,!1)),this._computeBoundingBox&&(r.hasBoundingInfo?r.getBoundingInfo().reConstruct(_,p,r._worldMatrix):r.buildBoundingInfo(_,p,r._worldMatrix))),this.afterUpdateParticles(e,t,n),this}dispose(){this.mesh?.dispose(),this.vars=null,this._positions=null,this._indices=null,this._normals=null,this._uvs=null,this._colors=null,this._indices32=null,this._positions32=null,this._uvs32=null,this._colors32=null}refreshVisibleSize(){return this._isVisibilityBoxLocked||this.mesh?.refreshBoundingInfo(),this}setVisibilityBox(e){if(!this.mesh)return;const t=e/2;this.mesh.buildBoundingInfo(new c.Pq(-t,-t,-t),new c.Pq(t,t,t))}get isAlwaysVisible(){return this._alwaysVisible}set isAlwaysVisible(e){this.mesh&&(this._alwaysVisible=e,this.mesh.alwaysSelectAsActiveMesh=e)}set computeParticleRotation(e){this._computeParticleRotation=e}set computeParticleColor(e){this._computeParticleColor=e}set computeParticleTexture(e){this._computeParticleTexture=e}get computeParticleColor(){return this._computeParticleColor}get computeParticleTexture(){return this._computeParticleTexture}set computeBoundingBox(e){this._computeBoundingBox=e}get computeBoundingBox(){return this._computeBoundingBox}initParticles(){}recycleParticle(e){return e}updateParticle(e){return e}beforeUpdateParticles(e,t,n){}afterUpdateParticles(e,t,n){}}var k,W=n(451);!function(e){e[e.Splat=0]="Splat",e[e.PointCloud=1]="PointCloud",e[e.Mesh=2]="Mesh",e[e.Reject=3]="Reject"}(k||(k={}));class q{constructor(e=q._DefaultLoadingOptions){this.name=r.B.name,this._assetContainer=null,this.extensions=r.B.extensions,this._loadingOptions=e}createPlugin(e){return new q(e[r.B.name])}async importMeshAsync(e,t,n,s,r,o){return this._parse(e,t,n,s).then((e=>({meshes:e,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}static _BuildPointCloud(e,t){if(!t.byteLength)return!1;const n=new Uint8Array(t),s=new Float32Array(t),r=n.length/32;return e.addPoints(r,(function(e,t){const r=s[8*t+0],o=s[8*t+1],i=s[8*t+2];e.position=new c.Pq(r,o,i);const a=n[32*t+24+0]/255,l=n[32*t+24+1]/255,u=n[32*t+24+2]/255;e.color=new W.ov(a,l,u,1)})),!0}static _BuildMesh(e,t){const n=new i.e("PLYMesh",e),s=new Uint8Array(t.data),r=new Float32Array(t.data),o=s.length/32,c=[],l=new a.P;for(let e=0;e<o;e++){const t=r[8*e+0],n=r[8*e+1],s=r[8*e+2];c.push(t,n,s)}if(t.hasVertexColors){const e=new Float32Array(4*o);for(let t=0;t<o;t++){const n=s[32*t+24+0]/255,r=s[32*t+24+1]/255,o=s[32*t+24+2]/255;e[4*t+0]=n,e[4*t+1]=r,e[4*t+2]=o,e[4*t+3]=1}l.colors=e}return l.positions=c,l.indices=t.faces,l.applyToMesh(n),n}_parseSPZ(e,t){const n=new Uint8Array(e),s=new Uint32Array(e),r=s[2],o=n[12],i=n[13];if(n[15]||1347635022!=s[0]||2!=s[1])return new Promise((e=>{e({mode:3,data:a,hasVertexColors:!1})}));const a=new ArrayBuffer(32*r),c=1/(1<<i),l=new Int32Array(1),u=new Uint8Array(l.buffer),f=function(e,t){return u[0]=e[t+0],u[1]=e[t+1],u[2]=e[t+2],u[3]=128&e[t+2]?255:0,l[0]*c};let h=16;const d=new Float32Array(a),_=new Float32Array(a),p=new Uint8ClampedArray(a),x=new Uint8ClampedArray(a);let v=1,m=0;this._loadingOptions.flipY||(v=-1,m=255);for(let e=0;e<r;e++)d[8*e+0]=f(n,h+0),d[8*e+1]=v*f(n,h+3),d[8*e+2]=v*f(n,h+6),h+=9;for(let e=0;e<r;e++){for(let t=0;t<3;t++){const s=(n[h+r+3*e+t]-127.5)/38.25;p[32*e+24+t]=P.X.Clamp(255*(.5+.282*s),0,255)}p[32*e+24+3]=n[h+e]}h+=4*r;for(let e=0;e<r;e++)_[8*e+3+0]=Math.exp(n[h+0]/16-10),_[8*e+3+1]=Math.exp(n[h+1]/16-10),_[8*e+3+2]=Math.exp(n[h+2]/16-10),h+=3;for(let e=0;e<r;e++){const t=n[h+0],s=n[h+1]*v+m,r=n[h+2]*v+m,o=t/127.5-1,i=s/127.5-1,a=r/127.5-1;x[32*e+28+1]=t,x[32*e+28+2]=s,x[32*e+28+3]=r;const c=1-(o*o+i*i+a*a);x[32*e+28+0]=127.5+127.5*Math.sqrt(c<0?0:c),h+=3}if(o){const e=3*((o+1)*(o+1)-1),s=Math.ceil(e/16);let i=h;const c=[],l=t.getEngine().getCaps().maxTextureSize,u=Math.ceil(r/l);for(let e=0;e<s;e++){const e=new Uint8Array(u*l*4*4);c.push(e)}for(let t=0;t<r;t++)for(let s=0;s<e;s++){const e=n[i++],r=Math.floor(s/16);c[r][s%16+16*t]=e}return new Promise((e=>{e({mode:0,data:a,hasVertexColors:!1,sh:c})}))}return new Promise((e=>{e({mode:0,data:a,hasVertexColors:!1})}))}_parse(e,t,n,s){const r=[],o=new ReadableStream({start(e){e.enqueue(new Uint8Array(n)),e.close()}}),i=new DecompressionStream("gzip"),a=o.pipeThrough(i);return new Promise((e=>{new Response(a).arrayBuffer().then((n=>{this._parseSPZ(n,t).then((e=>{const n=new z("GaussianSplatting",null,t,this._loadingOptions.keepInRam);n._parentContainer=this._assetContainer,r.push(n),n.updateData(e.data,e.sh)})),e(r)})).catch((()=>{q._ConvertPLYToSplat(n).then((async n=>{switch(n.mode){case 0:{const e=new z("GaussianSplatting",null,t,this._loadingOptions.keepInRam);e._parentContainer=this._assetContainer,r.push(e),e.updateData(n.data)}break;case 1:{const e=new N("PointCloud",1,t);q._BuildPointCloud(e,n.data)?await e.buildMeshAsync().then((e=>{r.push(e)})):e.dispose()}break;case 2:if(!n.faces)throw new Error("PLY mesh doesn't contain face informations.");r.push(q._BuildMesh(t,n));break;default:throw new Error("Unsupported Splat mode")}e(r)}))}))}))}loadAssetContainerAsync(e,t,n){const s=new M.WZ(e);return this._assetContainer=s,this.importMeshAsync(null,e,t,n).then((e=>(e.meshes.forEach((e=>s.meshes.push(e))),this._assetContainer=null,s))).catch((e=>{throw this._assetContainer=null,e}))}loadAsync(e,t,n){return this.importMeshAsync(null,e,t,n).then((()=>{}))}static _ConvertPLYToSplat(e){const t=new Uint8Array(e),n=(new TextDecoder).decode(t.slice(0,10240)),s=n.indexOf("end_header\n");if(s<0||!n)return new Promise((t=>{t({mode:0,data:e})}));const r=parseInt(/element vertex (\d+)\n/.exec(n)[1]),o=/element face (\d+)\n/.exec(n);let i=0;o&&(i=parseInt(o[1]));const a=/element chunk (\d+)\n/.exec(n);let c=0;a&&(c=parseInt(a[1]));let u=0,f=0;const h={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let d;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk"}(d||(d={}));let _=1;const p=[],x=[],v=n.slice(0,s).split("\n");for(const e of v)if(e.startsWith("property ")){const[,t,n]=e.split(" ");1==_?(x.push({name:n,type:t,offset:f}),f+=h[t]):0==_&&(p.push({name:n,type:t,offset:u}),u+=h[t]),h[t]||l.V.Warn(`Unsupported property type: ${t}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");"chunk"==t?_=1:"vertex"==t&&(_=0)}const m=u,g=f;return z.ConvertPLYWithSHToSplatAsync(e).then((t=>{const n=new DataView(e,s+11);let o=g*c+m*r;const a=[];if(i)for(let e=0;e<i;e++){const e=n.getUint8(o);if(3==e){o+=1;for(let t=0;t<e;t++){const e=n.getUint32(o+4*(2-t),!0);a.push(e)}o+=12}}if(c)return new Promise((e=>{e({mode:0,data:t.buffer,sh:t.sh,faces:a,hasVertexColors:!1})}));let l=0,u=0;const f=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],h=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let e=0;e<p.length;e++){const t=p[e];f.includes(t.name)&&l++,h.includes(t.name)&&u++}const d=l==f.length&&3==u,_=i?2:d?0:1;return new Promise((e=>{e({mode:_,data:t.buffer,sh:t.sh,faces:a,hasVertexColors:!!u})}))}))}}q._DefaultLoadingOptions={keepInRam:!1,flipY:!1},(0,s.qS)(new q)}}]);