"use strict";(self.webpackChunkGameClient=self.webpackChunkGameClient||[]).push([[5850],{5850:(e,t,r)=>{r.d(t,{KHR_draco_mesh_compression:()=>h});var o=r(9732),s=r(5743);function n(e,t,r,o,s){const n=e;let a=null,i=null,d=null;try{let e;a=new n.Decoder,i=new n.DecoderBuffer,i.Init(t,t.byteLength);const l=a.GetEncodedGeometryType(i);switch(l){case n.TRIANGULAR_MESH:{const t=new n.Mesh;if(e=a.DecodeBufferToMesh(i,t),!e.ok()||0===t.ptr)throw new Error(e.error_msg());const r=3*t.num_faces(),s=4*r,l=n._malloc(s);try{a.GetTrianglesUInt32Array(t,s,l);const e=new Uint32Array(r);e.set(new Uint32Array(n.HEAPF32.buffer,l,r)),o(e)}finally{n._free(l)}d=t;break}case n.POINT_CLOUD:{const t=new n.PointCloud;if(e=a.DecodeBufferToPointCloud(i,t),!e.ok()||!t.ptr)throw new Error(e.error_msg());d=t;break}default:throw new Error(`Invalid geometry type ${l}`)}const c=d.num_points(),u=(e,t,r,o)=>{const a=o.data_type(),i=o.num_components(),d=o.normalized(),l=o.byte_stride(),u=o.byte_offset(),f={[n.DT_FLOAT32]:{typedArrayConstructor:Float32Array,heap:n.HEAPF32},[n.DT_INT8]:{typedArrayConstructor:Int8Array,heap:n.HEAP8},[n.DT_INT16]:{typedArrayConstructor:Int16Array,heap:n.HEAP16},[n.DT_INT32]:{typedArrayConstructor:Int32Array,heap:n.HEAP32},[n.DT_UINT8]:{typedArrayConstructor:Uint8Array,heap:n.HEAPU8},[n.DT_UINT16]:{typedArrayConstructor:Uint16Array,heap:n.HEAPU16},[n.DT_UINT32]:{typedArrayConstructor:Uint32Array,heap:n.HEAPU32}}[a];if(!f)throw new Error(`Invalid data type ${a}`);const y=c*i,m=y*f.typedArrayConstructor.BYTES_PER_ELEMENT,h=n._malloc(m);try{e.GetAttributeDataArrayForAllPoints(t,o,a,m,h);const n=new f.typedArrayConstructor(f.heap.buffer,h,y);s(r,n.slice(),i,u,l,d)}finally{n._free(h)}};if(r)for(const e in r){const t=r[e],o=a.GetAttributeByUniqueId(d,t);u(a,d,e,o)}else{const e={position:n.POSITION,normal:n.NORMAL,color:n.COLOR,uv:n.TEX_COORD};for(const t in e){const r=a.GetAttributeId(d,e[t]);if(-1!==r){const e=a.GetAttribute(d,r);u(a,d,t,e)}}}return c}finally{d&&n.destroy(d),i&&n.destroy(i),a&&n.destroy(a)}}function a(){let e;onmessage=t=>{const r=t.data;switch(r.id){case"init":{r.url&&importScripts(r.url);const t=r.wasmBinary?{wasmBinary:r.wasmBinary}:{};e=DracoDecoderModule(t),postMessage({id:"initDone"});break}case"decodeMesh":if(!e)throw new Error("Draco decoder module is not available");e.then((e=>{const t=n(e,r.dataView,r.attributes,(e=>{postMessage({id:"indices",data:e},[e.buffer])}),((e,t,r,o,s,n)=>{postMessage({id:"attribute",kind:e,data:t,size:r,byteOffset:o,byteStride:s,normalized:n},[t.buffer])}));postMessage({id:"decodeMeshDone",totalVertices:t})}))}}}class i{constructor(e){if(e.workerPool)return void(this._workerPoolPromise=Promise.resolve(e.workerPool));const t=e.wasmBinary,r=e.numWorkers??("object"==typeof navigator&&navigator.hardwareConcurrency?Math.min(Math.floor(.5*navigator.hardwareConcurrency),4):1),n=r&&"function"==typeof Worker&&"function"==typeof URL,a=n||!e.jsModule,i=e.wasmUrl&&e.wasmBinaryUrl&&"object"==typeof WebAssembly?{url:a?o.S0.GetBabylonScriptURL(e.wasmUrl,!0):"",wasmBinaryPromise:t?Promise.resolve(t):o.S0.LoadFileAsync(o.S0.GetBabylonScriptURL(e.wasmBinaryUrl,!0))}:{url:a?o.S0.GetBabylonScriptURL(e.fallbackUrl):"",wasmBinaryPromise:Promise.resolve(void 0)};n?this._workerPoolPromise=i.wasmBinaryPromise.then((e=>{const t=this._getWorkerContent(),o=URL.createObjectURL(new Blob([t],{type:"application/javascript"}));return new s.h(r,(()=>function(e,t,r){return new Promise(((o,s)=>{const n=t=>{e.removeEventListener("error",n),e.removeEventListener("message",a),s(t)},a=t=>{"initDone"===t.data.id&&(e.removeEventListener("error",n),e.removeEventListener("message",a),o(e))};if(e.addEventListener("error",n),e.addEventListener("message",a),t){const o=t.slice(0);e.postMessage({id:"init",url:r,wasmBinary:o},[o])}else e.postMessage({id:"init",url:r})}))}(new Worker(o),e,i.url)))})):this._modulePromise=i.wasmBinaryPromise.then((async t=>{if(!this._isModuleAvailable()&&!e.jsModule){if(!i.url)throw new Error("Draco codec module is not available");await o.S0.LoadBabylonScriptAsync(i.url)}return this._createModuleAsync(t,e.jsModule)}))}async whenReadyAsync(){this._workerPoolPromise?await this._workerPoolPromise:this._modulePromise&&await this._modulePromise}dispose(){this._workerPoolPromise&&this._workerPoolPromise.then((e=>{e.dispose()})),delete this._workerPoolPromise,delete this._modulePromise}}var d=r(108),l=r(766),c=r(3039);class u extends i{static get DefaultAvailable(){return!!((e=u.DefaultConfiguration).wasmUrl&&(e.wasmBinary||e.wasmBinaryUrl)&&"object"==typeof WebAssembly||e.fallbackUrl);var e}static get Default(){return u._Default??(u._Default=new u),u._Default}static ResetDefault(e){u._Default&&(e||u._Default.dispose(),u._Default=null)}_isModuleAvailable(){return"undefined"!=typeof DracoDecoderModule}async _createModuleAsync(e,t){return{module:await(t||DracoDecoderModule)({wasmBinary:e})}}_getWorkerContent(){return`${n}(${a})()`}constructor(e=u.DefaultConfiguration){super(e)}decodeMeshToMeshDataAsync(e,t,r){const o=e instanceof ArrayBuffer?new Int8Array(e):new Int8Array(e.buffer,e.byteOffset,e.byteLength);if(this._workerPoolPromise)return this._workerPoolPromise.then((e=>new Promise(((s,n)=>{e.push(((e,a)=>{let i=null;const d=[],l=t=>{e.removeEventListener("error",l),e.removeEventListener("message",u),n(t),a()},u=t=>{const o=t.data;switch(o.id){case"indices":i=o.data;break;case"attribute":d.push({kind:o.kind,data:o.data,size:o.size,byteOffset:o.byteOffset,byteStride:o.byteStride,normalized:(n=o.kind,f=o.normalized,r&&void 0!==r[n]?(f!==r[n]&&c.V.Warn(`Normalized flag from Draco data (${f}) does not match normalized flag from glTF accessor (${r[n]}). Using flag from glTF accessor.`),r[n]):f)});break;case"decodeMeshDone":e.removeEventListener("error",l),e.removeEventListener("message",u),s({indices:i,attributes:d,totalVertices:o.totalVertices}),a()}var n,f};e.addEventListener("error",l),e.addEventListener("message",u);const f=o.slice();e.postMessage({id:"decodeMesh",dataView:f,attributes:t},[f.buffer])}))}))));if(this._modulePromise)return this._modulePromise.then((e=>{let r=null;const s=[],a=n(e.module,o,t,(e=>{r=e}),((e,t,r,o,n,a)=>{s.push({kind:e,data:t,size:r,byteOffset:o,byteStride:n,normalized:a})}));return{indices:r,attributes:s,totalVertices:a}}));throw new Error("Draco decoder module is not available")}async decodeMeshToGeometryAsync(e,t,r,o){const s=await this.decodeMeshToMeshDataAsync(r,o),n=new d.V(e,t);s.indices&&n.setIndices(s.indices);for(const e of s.attributes)n.setVerticesBuffer(new l.R(t.getEngine(),e.data,e.kind,!1,void 0,e.byteStride,void 0,e.byteOffset,e.size,void 0,e.normalized,!0),s.totalVertices);return n}async _decodeMeshToGeometryForGltfAsync(e,t,r,o,s,n){const a=await this.decodeMeshToMeshDataAsync(r,o,s),i=new d.V(e,t);n&&(i._boundingInfo=n,i.useBoundingInfoFromGeometry=!0),a.indices&&i.setIndices(a.indices);for(const e of a.attributes)i.setVerticesBuffer(new l.R(t.getEngine(),e.data,e.kind,!1,void 0,e.byteStride,void 0,e.byteOffset,e.size,void 0,e.normalized,!0),a.totalVertices);return i}}u.DefaultConfiguration={wasmUrl:`${o.S0._DefaultCdnUrl}/draco_wasm_wrapper_gltf.js`,wasmBinaryUrl:`${o.S0._DefaultCdnUrl}/draco_decoder_gltf.wasm`,fallbackUrl:`${o.S0._DefaultCdnUrl}/draco_decoder_gltf.js`},u._Default=null;var f=r(67),y=r(9046);const m="KHR_draco_mesh_compression";class h{constructor(e){this.name=m,this.useNormalizedFlagFromAccessor=!0,this._loader=e,this.enabled=u.DefaultAvailable&&this._loader.isExtensionUsed(m)}dispose(){delete this.dracoDecoder,this._loader=null}_loadVertexDataAsync(e,t,r){return f.BT.LoadExtensionAsync(e,t,this.name,((o,s)=>{if(null!=t.mode&&4!==t.mode&&5!==t.mode)throw new Error(`${e}: Unsupported mode ${t.mode}`);const n={},a={},i=(e,o)=>{const i=s.attributes[e];if(null!=i&&(r._delayInfo=r._delayInfo||[],-1===r._delayInfo.indexOf(o)&&r._delayInfo.push(o),n[o]=i,this.useNormalizedFlagFromAccessor)){const r=f.l2.TryGet(this._loader.gltf.accessors,t.attributes[e]);r&&(a[o]=r.normalized||!1)}};i("POSITION",l.R.PositionKind),i("NORMAL",l.R.NormalKind),i("TANGENT",l.R.TangentKind),i("TEXCOORD_0",l.R.UVKind),i("TEXCOORD_1",l.R.UV2Kind),i("TEXCOORD_2",l.R.UV3Kind),i("TEXCOORD_3",l.R.UV4Kind),i("TEXCOORD_4",l.R.UV5Kind),i("TEXCOORD_5",l.R.UV6Kind),i("JOINTS_0",l.R.MatricesIndicesKind),i("WEIGHTS_0",l.R.MatricesWeightsKind),i("COLOR_0",l.R.ColorKind);const d=f.l2.Get(o,this._loader.gltf.bufferViews,s.bufferView);return d._dracoBabylonGeometry||(d._dracoBabylonGeometry=this._loader.loadBufferViewAsync(`/bufferViews/${d.index}`,d).then((o=>{const s=this.dracoDecoder||u.Default,i=f.l2.TryGet(this._loader.gltf.accessors,t.attributes.POSITION),d=this._loader.parent.alwaysComputeBoundingBox||r.skeleton||!i?null:(0,f.dM)(i);return s._decodeMeshToGeometryForGltfAsync(r.name,this._loader.babylonScene,o,n,a,d).catch((t=>{throw new Error(`${e}: ${t.message}`)}))}))),d._dracoBabylonGeometry}))}}(0,y.Hg)(m),(0,y.Ye)(m,!0,(e=>new h(e)))}}]);