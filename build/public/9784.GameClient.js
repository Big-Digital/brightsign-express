"use strict";(self.webpackChunkGameClient=self.webpackChunkGameClient||[]).push([[9784],{9784:(e,t,s)=>{s.d(t,{EXT_mesh_gpu_instancing:()=>i});var o=s(4049),r=s(67),n=s(9046);s(3785);const a="EXT_mesh_gpu_instancing";class i{constructor(e){this.name=a,this._loader=e,this.enabled=this._loader.isExtensionUsed(a)}dispose(){this._loader=null}loadNodeAsync(e,t,s){return r.BT.LoadExtensionAsync(e,t,this.name,((e,n)=>{this._loader._disableInstancedMesh++;const a=this._loader.loadNodeAsync(`/nodes/${t.index}`,t,s);if(this._loader._disableInstancedMesh--,!t._primitiveBabylonMeshes)return a;const i=new Array;let c=0;const l=t=>{if(null==n.attributes[t])return void i.push(Promise.resolve(null));const s=r.l2.Get(`${e}/attributes/${t}`,this._loader.gltf.accessors,n.attributes[t]);if(i.push(this._loader._loadFloatAccessorAsync(`/accessors/${s.bufferView}`,s)),0===c)c=s.count;else if(c!==s.count)throw new Error(`${e}/attributes: Instance buffer accessors do not have the same count.`)};return l("TRANSLATION"),l("ROTATION"),l("SCALE"),a.then((e=>Promise.all(i).then((([s,r,n])=>{const a=new Float32Array(16*c);o.AA.Vector3[0].copyFromFloats(0,0,0),o.AA.Quaternion[0].copyFromFloats(0,0,0,1),o.AA.Vector3[1].copyFromFloats(1,1,1);for(let e=0;e<c;++e)s&&o.Pq.FromArrayToRef(s,3*e,o.AA.Vector3[0]),r&&o.PT.FromArrayToRef(r,4*e,o.AA.Quaternion[0]),n&&o.Pq.FromArrayToRef(n,3*e,o.AA.Vector3[1]),o.uq.ComposeToRef(o.AA.Vector3[1],o.AA.Quaternion[0],o.AA.Vector3[0],o.AA.Matrix[0]),o.AA.Matrix[0].copyToArray(a,16*e);for(const e of t._primitiveBabylonMeshes)e.thinInstanceSetBuffer("matrix",a,16,!0);return e}))))}))}}(0,n.Hg)(a),(0,n.Ye)(a,!0,(e=>new i(e)))}}]);