"use strict";(self.webpackChunkGameClient=self.webpackChunkGameClient||[]).push([[9518],{9518:(e,t,s)=>{s.d(t,{EXT_meshopt_compression:()=>c});var o=s(67),r=s(9732);let n=0,l=null;class u{static get Default(){return u._Default||(u._Default=new u),u._Default}constructor(){const e=u.Configuration.decoder;this._decoderModulePromise=r.S0.LoadBabylonScriptAsync(e.url).then((()=>MeshoptDecoder.ready))}dispose(){delete this._decoderModulePromise}decodeGltfBufferAsync(e,t,s,o,r){return this._decoderModulePromise.then((async()=>{0===n&&(MeshoptDecoder.useWorkers(1),n=1);const u=await MeshoptDecoder.decodeGltfBufferAsync(t,s,e,o,r);return null!==l&&clearTimeout(l),l=setTimeout((()=>{MeshoptDecoder.useWorkers(0),n=0,l=null}),1e3),u}))}}u.Configuration={decoder:{url:`${r.S0._DefaultCdnUrl}/meshopt_decoder.js`}},u._Default=null;var d=s(9046);const a="EXT_meshopt_compression";class c{constructor(e){this.name=a,this.enabled=e.isExtensionUsed(a),this._loader=e}dispose(){this._loader=null}loadBufferViewAsync(e,t){return o.BT.LoadExtensionAsync(e,t,this.name,((s,r)=>{const n=t;if(n._meshOptData)return n._meshOptData;const l=o.l2.Get(`${e}/buffer`,this._loader.gltf.buffers,r.buffer);return n._meshOptData=this._loader.loadBufferAsync(`/buffers/${l.index}`,l,r.byteOffset||0,r.byteLength).then((e=>u.Default.decodeGltfBufferAsync(e,r.count,r.byteStride,r.mode,r.filter))),n._meshOptData}))}}(0,d.Hg)(a),(0,d.Ye)(a,!0,(e=>new c(e)))}}]);